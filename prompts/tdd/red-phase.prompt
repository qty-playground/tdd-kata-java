# RED PHASE - Write Failing JUnit Tests

## üî¥ RED PHASE ACTIVE (Java SE + Maven)

**Goal: Write one failing JUnit test for new business rule**

* When test cases have multiple items, break them into multiple cycles and handle one at a time. Don't be greedy, don't rush.

## Strict File Modification Rules

### ‚úÖ ALLOWED - Can only modify these files:
- Any `*Test.java` files in `src/test/java/` directory
- Add test imports and test utilities
- Modify test fixtures and test data

### ‚ùå FORBIDDEN - Absolutely cannot modify:
- Any implementation files in `src/main/java/` directory
- Any implementation-related `.java` files  
- Any non-test code
- `pom.xml` or build configuration files (unless explicitly needed for test dependencies)

## Red Phase Objectives - CRITICAL TDD Purity Rules

### üéØ 1. ONE Test, ONE Rule - Absolute Principle
**NEVER write multiple tests in one Red Phase**

‚ùå **WRONG - Multiple tests:**
```java
@Test
void should_handle_multiples_of_three() {
    assertEquals("Foo", fooBarBar(3));
    assertEquals("Foo", fooBarBar(6));  // This is a second test case!
    assertEquals("Foo", fooBarBar(9));  // This is a third test case!
}
```

‚úÖ **CORRECT - Single test case:**
```java  
@Test
void should_return_foo_when_input_is_3() {
    // Only test input=3 case, don't peek at future requirements
    assertEquals("Foo", fooBarBar(3));
}
```

### üö´ 2. NO Future Peeking - Present Mindset
- **Only consider this one specific requirement**
- **Don't predict or prepare for future test cases**
- **Even if requirement description contains multiple examples, only pick one to test**

‚ùå **WRONG - Peeking at future:**
```java
// Requirement: "Numbers 3, 6, 9 should all return Foo"
@Test
void test_multiples_of_three() {
    assertEquals("Foo", fooBarBar(3));
    assertEquals("Foo", fooBarBar(6));  // Peeking at future!
    assertEquals("Foo", fooBarBar(9));  // Peeking at future!
}
```

‚úÖ **CORRECT - Present focus:**
```java
// Requirement: "Numbers 3, 6, 9 should all return Foo" 
// But I only test the first example
@Test
void should_return_foo_when_input_is_3() {
    assertEquals("Foo", fooBarBar(3));
}
```

### üìù 3. Minimal Test Structure (JUnit 5)
```java
@Test
void should_[specific_behavior]_when_[specific_condition]() {
    // Specifically describe what this one test verifies
    
    // Arrange - Prepare test data
    TargetClass target = new TargetClass();
    InputType input = specificInput;
    ExpectedType expected = expectedOutput;
    
    // Act - Execute method under test
    ActualType actual = target.targetMethod(input);
    
    // Assert - Verify result
    assertEquals(expected, actual);
}
```

### 4. Expected Failure Types (Java + JUnit 5)
```java
// Class doesn't exist yet - Compilation error
import com.example.services.NewService; // Class not found

// Method not implemented yet
@Test
void should_throw_exception_when_method_not_implemented() {
    TargetService service = new TargetService();
    assertThrows(UnsupportedOperationException.class, () -> {
        service.methodName();
    });
}

// Validation rule not implemented
@Test
void should_throw_validation_error_for_invalid_input() {
    ValidationService service = new ValidationService();
    assertThrows(ValidationException.class, () -> {
        service.validate("invalid_input");
    });
}

// Method returns null or wrong value
@Test
void should_return_correct_value() {
    CalculationService service = new CalculationService();
    // Expected: null or wrong value initially
    String result = service.process("input");
    assertEquals("expected_result", result); // Will fail
}

// Exception type mismatch
@Test
void should_handle_edge_case() {
    EdgeCaseService service = new EdgeCaseService();
    // Expected: different exception or no exception
    assertThrows(SpecificException.class, () -> {
        service.handleEdgeCase("edge_input");
    });
}
```

## Red Phase Completion Criteria

### ‚úÖ Phase Complete When:
1. **Test is written** - New JUnit test is complete
2. **Test runs and fails** - Execute test command to confirm test is discovered and fails
3. **Test fails correctly** - Test fails for the right reason (UnsupportedOperationException, ClassNotFoundException, AssertionFailure etc)
4. **Test is focused** - Only tests one business rule
5. **Imports are minimal** - Only import necessary classes and JUnit assertions

### üìã Red Phase Checklist:
- [ ] Test written in correct `src/test/java/` directory
- [ ] Test name clearly describes business rule
- [ ] Execute test command to confirm test is discovered and fails (with correct reason)
- [ ] No modification to any `src/main/java/` implementation code
- [ ] Ready to enter Green Phase

### üîß Recommended Test Execution Commands (Prefer Wrapper):
```bash
# Maven - prefer wrapper
./mvnw test              # If mvnw exists
mvn test                 # fallback

# Gradle - prefer wrapper  
./gradlew test           # If gradlew exists
gradle test              # fallback
```

## Transition to Green Phase

Red Phase complete output:
```
üî¥ ‚Üí üü¢ RED PHASE COMPLETE
Failed test created: [test_method_name]
Reason for failure: [NotImplementedError/ImportError/etc]
Ready for GREEN PHASE
```

## Test Discovery Guidelines

### Ensure tests are discovered by Maven/Gradle:
```bash
# Maven - Check test discovery (prefer wrapper)
./mvnw test -DdryRun=true   # If mvnw exists
./mvnw test --help          # View available options
./mvnw test -Dtest=UserServiceTest  # Run specific test class

# If no wrapper, fallback to:
mvn test -DdryRun=true
mvn test -Dtest=UserServiceTest

# Gradle - Check test discovery (prefer wrapper)
./gradlew test --dry-run    # If gradlew exists
./gradlew test --info       # Show detailed information
./gradlew test --tests UserServiceTest  # Run specific test class

# If no wrapper, fallback to:
gradle test --dry-run
gradle test --tests UserServiceTest

# If tests not discovered, check:
# 1. File name follows *Test.java or *Tests.java pattern
# 2. Class is in correct package
# 3. File path is in src/test/java/ directory
# 4. No compilation errors preventing execution
# 5. Test methods have @Test annotation
```

## Common Red Phase Mistakes to Avoid

‚ùå **Don't**:
- Modify src/main/java/ implementation code
- Write multiple rules in one test
- Let test accidentally pass
- Over-complicated test setup
- Forget to confirm test is discovered by Maven/Gradle

‚úÖ **Do**:
- Focus on writing one failing JUnit test
- Clearly express business rule
- Confirm failure reason is correct (compilation error, assertion failure, exception)
- Keep test simple and clear
- First confirm test discovery works (mvn test or gradle test)