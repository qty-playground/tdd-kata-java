# GREEN PHASE - Minimal Java Implementation

## üü¢ GREEN PHASE ACTIVE (Java SE + Maven)

**Goal: Use minimal Java implementation to make failing JUnit tests pass**

## üéØ File Rules
**‚úÖ ONLY modify:** `src/main/java/` implementation files  
**‚ùå NEVER touch:** `src/test/java/` test files

## Green Phase Objectives

### 1. Make Test Pass with Minimal Java Code
```java
// Minimal implementation - hardcode is completely OK
public class UserService {
    public User authenticateUser(String email, String password) {
        // Direct hardcode, make test pass first
        return new User("hardcoded@example.com");
    }
        
    public boolean validateEmail(String email) {
        // Minimal implementation
        return true;
    }
        
    public int calculateScore(Map<String, Object> data) {
        // Fixed return value is fine
        return 42;
    }
}
```

### 2. Implementation Priorities
1. **Syntactically correct** > Logically correct
2. **Tests pass** > Code elegance  
3. **Quick implementation** > Perfect design
4. **Hardcode** > Complex logic

### 3. Acceptable Green Phase Patterns (Java)
```java
// Pattern 1: Direct return expected value
public String getUserName() {
    return "John Doe";
}

// Pattern 2: Simple conditional logic
public boolean isValid(String value) {
    if ("expected_value".equals(value)) {
        return true;
    }
    return false;
}

// Pattern 3: Throw expected exception
public void validateInput(String data) {
    if ("invalid".equals(data)) {
        throw new ValidationException("Invalid input");
    }
}

// Pattern 4: Create fake objects
public User findUser(String userId) {
    return new User(userId, "fake_email@test.com", "fake_name");
}

// Pattern 5: Throw UnsupportedOperationException
public String complexMethod() {
    throw new UnsupportedOperationException("Not implemented yet");
}
```

## ‚úÖ Completion Criteria
1. **All tests pass** - Green status achieved
2. **Minimal implementation** - Simplest possible solution
3. **Only implementation files modified** - No test changes

### üîß Execute Tests:
Run tests to confirm all pass

## Implementation Strategies

### Strategy 1: Direct Return (Java)
```java
public String methodName() {
    return "expected_result";
}
```

### Strategy 2: Simple Conditional (Java)
```java  
public String methodName(String inputValue) {
    if ("specific_case".equals(inputValue)) {
        return "expected_result";
    }
    return "default_result";
}
```

### Strategy 3: Exception Throwing (Java)
```java
public String methodName(String inputValue) {
    if ("invalid".equals(inputValue)) {
        throw new CustomException("Expected error");
    }
    return "success";
}
```

### Strategy 4: Create Stub Classes (Java)
```java
// Create minimal class to satisfy compilation
public class ServiceStub {
    public String process(String input) {
        return "stub_result";  // Hardcoded response
    }
}
```

## ‚Üí Next: REFACTOR PHASE
Mandatory code review + optional improvements

## Common Green Phase Mistakes to Avoid

‚ùå **Don't**:
- Modify src/test/java/ test files
- Over-engineer or optimize (over-engineering)
- Implement unnecessary features
- Consider future requirements
- Add complex business logic

‚úÖ **Do**:  
- Use simplest Java implementation to make JUnit tests pass
- Hardcoded values are completely acceptable
- Focus on current failing test
- Quick and direct solutions
- Create necessary classes and packages
- Use public method signatures that match test expectations