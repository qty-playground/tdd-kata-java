# TDD Session Controller (Java SE)

## â˜• Java SE TDD Workflow

### ğŸ¯ Requirements Analysis Flow When New Requirements Received  
**Requirements analysis must be performed before entering any TDD phase**

#### Mandatory Reflection Checkpoints:
```
â“ Analysis Questions:
1. Does this requirement contain multiple independent test cases?
2. If yes, how many TDD cycles should it be broken into?
3. What specific method signatures and inputâ†’output should each cycle test?

ğŸ“‹ Analysis Output Format:
TDD Cycles Planning:
Cycle 1: [test method description] - Input: X, Expected: Y
Cycle 2: [test method description] - Input: X, Expected: Y  
...
Total: N cycles
Current: Cycle 1
```

#### ğŸš¨ Requirements That Need Decomposition:
- **Multiple concrete examples**: "Numbers 3, 6, 9 should all return Foo" â†’ 3 test methods
- **Different rule combinations**: "Basic rules + Foo rules + Compound rules" â†’ At least 3 test cycles  
- **Boundary condition enumeration**: "Handle positive, negative, zero" â†’ 3 test cases

#### âœ… Single Case Requirements:
- **One concrete input-output**: "When input is 3, should return Foo" â†’ 1 test method
- **Single rule validation**: "Verify email format checking" â†’ 1 test cycle

## State Machine Control

```
[Start] â†’ Red â†’ Green â†’ Refactor â†’ Red â†’ ... â†’ [Wait for New Rule]
```

## Current State Detection

### Determine Current Phase
Check current situation to decide which phase to be in:

1. **Enter Red Phase when:**
   - Requirements analysis completed, current test case is clear
   - Ready to start a specific TDD cycle
   - Previous refactor phase completed, entering next cycle
   - Have a clear single test case to implement

2. **Enter Green Phase when:**
   - Red phase completed (have failing test)
   - New failing test exists in src/test/java/ directory
   - Need to implement code to make tests pass

3. **Enter Refactor Phase when:**
   - Green phase completed (tests pass)
   - All tests are green
   - Code has improvement opportunities (duplication, naming, structure)

4. **Enter Wait State when:**
   - Refactor phase completed
   - No new business rules
   - No obvious code improvement needs

## Phase Transition Commands - STRICT ENFORCEMENT

### ğŸš¨ CRITICAL: Every Phase Completion Must Have COMMIT Report
**All phases must submit commit to record progress status when completed**

### Requirements Analysis and Planning
```
ğŸ” REQUIREMENTS ANALYSIS:
1. Analyze if received requirements contain multiple test cases
2. Decompose into independent inputâ†’output cases
3. Plan how many TDD cycles are needed
4. Focus on the first case to handle
Output: TDD Cycles Planning list

ğŸ“ MANDATORY COMMIT:
git commit --allow-empty -m "plan: TDD cycles planning completed

ğŸ“‹ Planning Report:
1. Current phase and what was done: PLANNING PHASE - Requirements analysis completed
2. Discoveries and problems encountered: [List discovered case count and complexity]
3. Next phase and planned actions: RED PHASE - Start first test case
Cycles: [List all cycles]
Current: Cycle 1 - [Specific case]
"
```

### Start Red Phase
```
Entering RED PHASE - Cycle X
Use @prompts/tdd/red-phase.prompt
Goal: Write failing JUnit test for current cycle case
Current case: [Specific input] â†’ [Expected output]
Execute: ./mvnw test or ./gradlew test (prefer wrapper) to confirm test failure

ğŸ“ MANDATORY COMMIT WHEN COMPLETE:
git add .
git commit -m "red: failing test for [specific case] 

ğŸ”´ Red Phase Report:
1. Current phase and what was done: RED PHASE - Failing test completed
2. Discoveries and problems encountered: [Test failure reasons, compilation issues, etc.]
3. Next phase and planned actions: GREEN PHASE - Implement minimal code to make test pass
Test created: [test method name]
Failure reason: [Specific failure reason]
"
```

### Start Green Phase  
```
Entering GREEN PHASE
Use @prompts/tdd/green-phase.prompt  
Goal: Minimal implementation to make JUnit tests pass
Execute: ./mvnw test or ./gradlew test (prefer wrapper) to confirm tests pass

ğŸ“ MANDATORY COMMIT WHEN COMPLETE:
git add .
git commit -m "green: minimal implementation for [specific case]

ğŸŸ¢ Green Phase Report:
1. Current phase and what was done: GREEN PHASE - Minimal implementation completed
2. Discoveries and problems encountered: [Implementation discoveries, technical choices, etc.]
3. Next phase and planned actions: REFACTOR PHASE - Mandatory code review
Implementation: [Implemented methods/classes]
All tests: âœ… PASSING
"
```

### Start Refactor Phase - ğŸš¨ NEVER SKIP THIS PHASE
```
Entering REFACTOR PHASE - âš ï¸ MANDATORY PHASE
Use @prompts/tdd/refactor-phase.prompt
Goal: Mandatory code review + Optional code improvements
Execute: ./mvnw test or ./gradlew test (prefer wrapper) frequently to confirm tests still pass

ğŸš¨ CRITICAL RULE: This phase must never be skipped, even if no refactoring is done, code review is mandatory

ğŸ“ MANDATORY COMMIT (choose one):
# If refactoring done
git add .
git commit -m "refactor: improve code quality

ğŸ”§ Refactor Phase Report:
1. Current phase and what was done: REFACTOR PHASE - Refactoring completed
2. Discoveries and problems encountered: [Refactoring discoveries, improvements made]
3. Next phase and planned actions: [NEXT RED PHASE for Cycle X+1 / WAIT STATE]
ğŸ” Code Review: âœ… DONE
Improvements: [Specific improvements made]
All tests: âœ… PASSING
"

# If no refactoring needed
git commit --allow-empty -m "refactor: code review completed - no changes needed

ğŸ”§ Refactor Phase Report:
1. Current phase and what was done: REFACTOR PHASE - Code review completed
2. Discoveries and problems encountered: [Code review findings]
3. Next phase and planned actions: [NEXT RED PHASE for Cycle X+1 / WAIT STATE]
ğŸ” Code Review: âœ… DONE
Decision: No refactoring - [Specific reasons]
Code status: [Code status assessment]
All tests: âœ… PASSING
"
```

### Cycle Completion Check
```
ğŸ“‹ CYCLE COMPLETION CHECK - MANDATORY:
Check if there are unhandled test cases:
- If yes: Enter next RED PHASE for next cycle
- If no: Enter WAIT STATE

ğŸ“ MANDATORY SESSION STATUS COMMIT:
git commit --allow-empty -m "session: TDD cycle [X] completed

ğŸ“Š Session Status Report:
1. Current phase and what was done: CYCLE [X] COMPLETE
2. Discoveries and problems encountered: [Overall cycle insights]
3. Next phase and planned actions: [NEXT CYCLE / WAIT FOR NEW REQUIREMENTS]
Completed cycles: [X / Total]
Remaining cycles: [List remaining cases or NONE]
Overall progress: [Overall progress assessment]
"
```

### Wait for New Rules
```
ğŸ¯ WAIT STATE - Waiting for New Requirements
TDD SESSION READY
Waiting for new business rules or problem exploration
Ready to start new requirements analysis
```

## Session Management

### Current Session State
- Main Class: `src/main/java/com/example/ExampleService.java`
- Test Class: `src/test/java/com/example/ExampleServiceTest.java`  
- Current Phase: `[PLANNING|RED|GREEN|REFACTOR|WAITING]`
- Current Cycle: `Cycle X / Total Y cycles`
- Current Test Case: `Specific input â†’ Expected output`
- Remaining Cases: `List of remaining cases to handle`
- Build Tool: `[Maven|Gradle]`
- Java Version: `Java 17+ recommended`

### Phase Completion Checklist
- [ ] Planning: Requirements analyzed, cycles planned
- [ ] Red: Test written and failing (current cycle)
- [ ] Green: Test passing, functionality implemented (current cycle)
- [ ] Refactor: Code improved, tests still passing (current cycle)
- [ ] Cycle Complete: Current cycle finished, check for next one
- [ ] Session: All cycles completed, ready for new business rules

## State Transition Rules

1. **Requirements Analysis First**: Receive requirements â†’ Analyze & decompose â†’ Enter TDD
2. **Strict Sequence**: Red â†’ Green â†’ Refactor (for each cycle)
3. **Cannot Skip**: Every phase must be completed
4. **Single Responsibility**: Each phase only does its designated work  
5. **File Constraints**: Strictly follow file modification restrictions
6. **Completion Confirmation**: Confirm goals achieved before phase ends
7. **Cycle Management**: After completing one round, check for next case to handle

## â˜• Java SE Specific Guidelines

### Project Structure (Maven Standard)
```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/java/
â”‚   â”‚   â””â”€â”€ com/example/
â”‚   â”‚       â””â”€â”€ YourClass.java
â”‚   â””â”€â”€ test/java/
â”‚       â””â”€â”€ com/example/
â”‚           â””â”€â”€ YourClassTest.java
â”œâ”€â”€ pom.xml (Maven) or build.gradle (Gradle)
â””â”€â”€ README.md
```

### Test Framework Choice
- **JUnit 5** (recommended): `@Test`, `assertEquals()`, `assertThrows()`
- **JUnit 4** (compatible): `@Test`, `Assert.assertEquals()`
- **TestNG** (alternative): `@Test`, `Assert.assertEquals()`

### Recommended Dependency Configuration (Maven pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.9.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### Common Test Commands (Prefer Wrapper)
```bash
# Maven - prefer wrapper
./mvnw test                    # Run all tests (if mvnw exists)
./mvnw test -Dtest=ClassName   # Run specific test class
./mvnw compile                 # Compile main code
./mvnw clean compile          # Clean then recompile

# If no wrapper, fallback to:
mvn test
mvn test -Dtest=ClassName
mvn compile
mvn clean compile

# Gradle - prefer wrapper
./gradlew test                 # Run all tests (if gradlew exists)
./gradlew test --tests ClassName  # Run specific test class
./gradlew compileJava         # Compile main code
./gradlew clean build         # Clean then rebuild

# If no wrapper, fallback to:
gradle test
gradle test --tests ClassName
gradle compileJava
gradle clean build
```

### Java TDD Best Practices
1. **Test Method Naming**: `should_ReturnExpected_When_GivenInput()`
2. **Test Class Naming**: `ClassNameTest` or `ClassNameTests`
3. **One Test One Assertion**: Keep tests concise and clear
4. **Use AAA Pattern**: Arrange â†’ Act â†’ Assert
5. **Appropriate use of @BeforeEach** and **@AfterEach** for setup/cleanup

### Example Test Template (JUnit 5)
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class ExampleServiceTest {
    
    @Test
    void should_ReturnExpected_When_GivenInput() {
        // Arrange
        ExampleService service = new ExampleService();
        int input = 3;
        String expected = "Foo";
        
        // Act
        String actual = service.process(input);
        
        // Assert
        assertEquals(expected, actual);
    }
}
```