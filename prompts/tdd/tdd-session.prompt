# TDD Session Controller (Java SE)

## ☕ Java SE TDD Workflow

### 🎯 Requirements Analysis Flow When New Requirements Received  
**Requirements analysis must be performed before entering any TDD phase**

#### Mandatory Reflection Checkpoints:
```
❓ Analysis Questions:
1. Does this requirement contain multiple independent test cases?
2. If yes, how many TDD cycles should it be broken into?
3. What specific method signatures and input→output should each cycle test?

📋 Analysis Output Format:
TDD Cycles Planning:
Cycle 1: [test method description] - Input: X, Expected: Y
Cycle 2: [test method description] - Input: X, Expected: Y  
...
Total: N cycles
Current: Cycle 1
```

#### 🚨 Requirements That Need Decomposition:
- **Multiple concrete examples**: "Numbers 3, 6, 9 should all return Foo" → 3 test methods
- **Different rule combinations**: "Basic rules + Foo rules + Compound rules" → At least 3 test cycles  
- **Boundary condition enumeration**: "Handle positive, negative, zero" → 3 test cases

#### ✅ Single Case Requirements:
- **One concrete input-output**: "When input is 3, should return Foo" → 1 test method
- **Single rule validation**: "Verify email format checking" → 1 test cycle

## State Machine Control

```
[Start] → Red → Green → Refactor → Red → ... → [Wait for New Rule]
```

## Current State Detection

### Determine Current Phase
Check current situation to decide which phase to be in:

1. **Enter Red Phase when:**
   - Requirements analysis completed, current test case is clear
   - Ready to start a specific TDD cycle
   - Previous refactor phase completed, entering next cycle
   - Have a clear single test case to implement

2. **Enter Green Phase when:**
   - Red phase completed (have failing test)
   - New failing test exists in src/test/java/ directory
   - Need to implement code to make tests pass

3. **Enter Refactor Phase when:**
   - Green phase completed (tests pass)
   - All tests are green
   - Code has improvement opportunities (duplication, naming, structure)

4. **Enter Wait State when:**
   - Refactor phase completed
   - No new business rules
   - No obvious code improvement needs

## Phase Transition Commands - STRICT ENFORCEMENT

### 🚨 CRITICAL: Every Phase Completion Must Have COMMIT Report
**All phases must submit commit to record progress status when completed**

### Requirements Analysis and Planning
```
🔍 REQUIREMENTS ANALYSIS:
1. Analyze if received requirements contain multiple test cases
2. Decompose into independent input→output cases
3. Plan how many TDD cycles are needed
4. Focus on the first case to handle
Output: TDD Cycles Planning list

📝 MANDATORY COMMIT:
git commit --allow-empty -m "plan: TDD cycles planning completed

📋 Planning Report:
1. Current phase and what was done: PLANNING PHASE - Requirements analysis completed
2. Discoveries and problems encountered: [List discovered case count and complexity]
3. Next phase and planned actions: RED PHASE - Start first test case
Cycles: [List all cycles]
Current: Cycle 1 - [Specific case]
"
```

### Start Red Phase
```
Entering RED PHASE - Cycle X
Use @prompts/tdd/red-phase.prompt
Goal: Write failing JUnit test for current cycle case
Current case: [Specific input] → [Expected output]
Execute: ./mvnw test or ./gradlew test (prefer wrapper) to confirm test failure

📝 MANDATORY COMMIT WHEN COMPLETE:
git add .
git commit -m "red: failing test for [specific case] 

🔴 Red Phase Report:
1. Current phase and what was done: RED PHASE - Failing test completed
2. Discoveries and problems encountered: [Test failure reasons, compilation issues, etc.]
3. Next phase and planned actions: GREEN PHASE - Implement minimal code to make test pass
Test created: [test method name]
Failure reason: [Specific failure reason]
"
```

### Start Green Phase  
```
Entering GREEN PHASE
Use @prompts/tdd/green-phase.prompt  
Goal: Minimal implementation to make JUnit tests pass
Execute: ./mvnw test or ./gradlew test (prefer wrapper) to confirm tests pass

📝 MANDATORY COMMIT WHEN COMPLETE:
git add .
git commit -m "green: minimal implementation for [specific case]

🟢 Green Phase Report:
1. Current phase and what was done: GREEN PHASE - Minimal implementation completed
2. Discoveries and problems encountered: [Implementation discoveries, technical choices, etc.]
3. Next phase and planned actions: REFACTOR PHASE - Mandatory code review
Implementation: [Implemented methods/classes]
All tests: ✅ PASSING
"
```

### Start Refactor Phase - 🚨 NEVER SKIP THIS PHASE
```
Entering REFACTOR PHASE - ⚠️ MANDATORY PHASE
Use @prompts/tdd/refactor-phase.prompt
Goal: Mandatory code review + Optional code improvements
Execute: ./mvnw test or ./gradlew test (prefer wrapper) frequently to confirm tests still pass

🚨 CRITICAL RULE: This phase must never be skipped, even if no refactoring is done, code review is mandatory

📝 MANDATORY COMMIT (choose one):
# If refactoring done
git add .
git commit -m "refactor: improve code quality

🔧 Refactor Phase Report:
1. Current phase and what was done: REFACTOR PHASE - Refactoring completed
2. Discoveries and problems encountered: [Refactoring discoveries, improvements made]
3. Next phase and planned actions: [NEXT RED PHASE for Cycle X+1 / WAIT STATE]
🔍 Code Review: ✅ DONE
Improvements: [Specific improvements made]
All tests: ✅ PASSING
"

# If no refactoring needed
git commit --allow-empty -m "refactor: code review completed - no changes needed

🔧 Refactor Phase Report:
1. Current phase and what was done: REFACTOR PHASE - Code review completed
2. Discoveries and problems encountered: [Code review findings]
3. Next phase and planned actions: [NEXT RED PHASE for Cycle X+1 / WAIT STATE]
🔍 Code Review: ✅ DONE
Decision: No refactoring - [Specific reasons]
Code status: [Code status assessment]
All tests: ✅ PASSING
"
```

### Cycle Completion Check
```
📋 CYCLE COMPLETION CHECK - MANDATORY:
Check if there are unhandled test cases:
- If yes: Enter next RED PHASE for next cycle
- If no: Enter WAIT STATE

📝 MANDATORY SESSION STATUS COMMIT:
git commit --allow-empty -m "session: TDD cycle [X] completed

📊 Session Status Report:
1. Current phase and what was done: CYCLE [X] COMPLETE
2. Discoveries and problems encountered: [Overall cycle insights]
3. Next phase and planned actions: [NEXT CYCLE / WAIT FOR NEW REQUIREMENTS]
Completed cycles: [X / Total]
Remaining cycles: [List remaining cases or NONE]
Overall progress: [Overall progress assessment]
"
```

### Wait for New Rules
```
🎯 WAIT STATE - Waiting for New Requirements
TDD SESSION READY
Waiting for new business rules or problem exploration
Ready to start new requirements analysis
```

## Session Management

### Current Session State
- Main Class: `src/main/java/com/example/ExampleService.java`
- Test Class: `src/test/java/com/example/ExampleServiceTest.java`  
- Current Phase: `[PLANNING|RED|GREEN|REFACTOR|WAITING]`
- Current Cycle: `Cycle X / Total Y cycles`
- Current Test Case: `Specific input → Expected output`
- Remaining Cases: `List of remaining cases to handle`
- Build Tool: `[Maven|Gradle]`
- Java Version: `Java 17+ recommended`

### Phase Completion Checklist
- [ ] Planning: Requirements analyzed, cycles planned
- [ ] Red: Test written and failing (current cycle)
- [ ] Green: Test passing, functionality implemented (current cycle)
- [ ] Refactor: Code improved, tests still passing (current cycle)
- [ ] Cycle Complete: Current cycle finished, check for next one
- [ ] Session: All cycles completed, ready for new business rules

## State Transition Rules

1. **Requirements Analysis First**: Receive requirements → Analyze & decompose → Enter TDD
2. **Strict Sequence**: Red → Green → Refactor (for each cycle)
3. **Cannot Skip**: Every phase must be completed
4. **Single Responsibility**: Each phase only does its designated work  
5. **File Constraints**: Strictly follow file modification restrictions
6. **Completion Confirmation**: Confirm goals achieved before phase ends
7. **Cycle Management**: After completing one round, check for next case to handle

## ☕ Java SE Specific Guidelines

### Project Structure (Maven Standard)
```
project-root/
├── src/
│   ├── main/java/
│   │   └── com/example/
│   │       └── YourClass.java
│   └── test/java/
│       └── com/example/
│           └── YourClassTest.java
├── pom.xml (Maven) or build.gradle (Gradle)
└── README.md
```

### Test Framework Choice
- **JUnit 5** (recommended): `@Test`, `assertEquals()`, `assertThrows()`
- **JUnit 4** (compatible): `@Test`, `Assert.assertEquals()`
- **TestNG** (alternative): `@Test`, `Assert.assertEquals()`

### Recommended Dependency Configuration (Maven pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.9.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### Common Test Commands (Prefer Wrapper)
```bash
# Maven - prefer wrapper
./mvnw test                    # Run all tests (if mvnw exists)
./mvnw test -Dtest=ClassName   # Run specific test class
./mvnw compile                 # Compile main code
./mvnw clean compile          # Clean then recompile

# If no wrapper, fallback to:
mvn test
mvn test -Dtest=ClassName
mvn compile
mvn clean compile

# Gradle - prefer wrapper
./gradlew test                 # Run all tests (if gradlew exists)
./gradlew test --tests ClassName  # Run specific test class
./gradlew compileJava         # Compile main code
./gradlew clean build         # Clean then rebuild

# If no wrapper, fallback to:
gradle test
gradle test --tests ClassName
gradle compileJava
gradle clean build
```

### Java TDD Best Practices
1. **Test Method Naming**: `should_ReturnExpected_When_GivenInput()`
2. **Test Class Naming**: `ClassNameTest` or `ClassNameTests`
3. **One Test One Assertion**: Keep tests concise and clear
4. **Use AAA Pattern**: Arrange → Act → Assert
5. **Appropriate use of @BeforeEach** and **@AfterEach** for setup/cleanup

### Example Test Template (JUnit 5)
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class ExampleServiceTest {
    
    @Test
    void should_ReturnExpected_When_GivenInput() {
        // Arrange
        ExampleService service = new ExampleService();
        int input = 3;
        String expected = "Foo";
        
        // Act
        String actual = service.process(input);
        
        // Assert
        assertEquals(expected, actual);
    }
}
```